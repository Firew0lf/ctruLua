# -- LDoc template by Reuh.
# -- Generates sublime-completions files which can be used in Sublime Text 3 for autocompletion.
# -- Based on the HTML template, so generated files will contain lots of comments with additionnal data not handled by ST.
# -- I tried to make the generated files human-readable, so they may be used instead of the HTML documentation.
# -- Typical usage: ldoc . --template ./ --ext sublime-completions --dir ./sublimetext/
#
# local scope = "source.lua"
# local function e(str) return str:gsub("\"", "\\\"") end -- escape json string ("str")
# local function indent(indentation, str) -- indent str (except first line) with indentation
# 	return str:gsub("(.-)\n", indentation.."%1\n"):gsub("\n([^\n]*)$", "\n"..indentation.."%1"):gsub("^"..indentation, "")
# end
# local function displayName(item) return item.type == "function" and item.name..item.args or item.name end -- nice name
# local function autocompleteName(item) -- ST-autocomplete name
# 	if item.type == "function" then
#		local i = 1
# 		local args = "("
# 		for arg in (item.args:match("^%((.*)%)$")..","):gmatch("%s*([^,]+)%,") do
# 			args = args.."${"..i..":"..arg.."}, "
#			i = i +1
# 		end
# 		return item.name..args:gsub("%, $", "")..")"
# 	else return item.name end
# end
/*
Title: $(ldoc.title)
Project: $(ldoc.project)
Description: $(ldoc.description)
# if ldoc.single then
(Single module-project)
# end
# if not module then

Project contents:
# for kind, mods in ldoc.kinds() do
	$(kind)
# 	for m in mods() do
		$(m.name): $(m.summary)
# 	end
# end
*/
# else -- if not module
*/

/*
Module: $(module.name)
Summary: $(module.summary)
Description: $(module.description)

Module contents:
# for kind, items in module.kinds() do
	$(kind)
# 	for item in items() do
		$(item.type) $(displayName(item))
# 	end
# end
*/

/* Completions */
{
	"scope": "$(e(scope))",

	"completions": [
# for kind, items in module.kinds() do
		/* $(kind) */
# 	for item in items() do
		/*
		$(item.type) $(displayName(item))
		Summary: $(item.summary)
		Description: $(indent("\t\t\t", item.description))
# 		if item.type == "function" then
		Parameters:
#			for p in item.params:iter() do
#				local default = item:default_of_param(p)
#				if default == true then default = "(optional)"
#				elseif default then default = "(defaults to "..default..")" end
			($(item:type_of_param(p))) $(item:display_name_of(p)):$(item.params.map[p]) $(default)
#			end
#			local retgroups = item.retgroups or {}
		Returns:
# 			for i, group in ldoc.ipairs(retgroups) do
#				for ret in group:iter() do
			($(ret.type)) $(indent("\t\t\t", ret.text))
#				end
#				if i < #retgroups then
			---or---
#				end
#			end
#		end
# 		if item.usage then
		Usage:
# 			for i, usage in ldoc.ipairs(item.usage) do
			$(sep)$(indent("\t\t\t", usage:gsub("^\n", "")))
#				if i < #item.usage then
			--------
#				end
# 			end
# 		end
# 		if item.see then
		See also:
# 			for see in item.see:iter() do
			$(see.mod.name): $(see.name)
# 			end
# 		end
		*/
# 		for pos in (module.name.."."):gmatch("()[^.]+%.") do
# 			local prefix = e(module.name:sub(pos) .. (item.name:match("^[%.%:]") and "" or "."))
		{
			"trigger": "$(prefix)$(e(item.name))\t$(e(item.summary))",
			"contents": "$(prefix)$(e(autocompleteName(item)))"
		},
# 		end
# 	end
# end
	]
}
# end -- if not module

/* Generated by LDoc; sublime-completions template by Reuh. Last updated $(ldoc.updatetime).*/
